<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<title>WebRTC – automatyczne parowanie</title>
<style>
	*
	{
		margin: 0;
		padding: 0;
		border: none;
		background: rgba(0,0,0,0);
		-webkit-user-drag: none;
		user-drag: none;
	}
	body
	{
		background: black;
	}
	#keyboard
	{
		position: fixed;
		bottom: 0;
		left: 1vw;
		width: 98vw;
		background: #1b1b1b;
		border-top: solid 0.4vh #252525;
		touch-action: none;
		user-select: none;
		-webkit-user-drag: none;
	}
	#keyboard > .box
	{
		position: relative;
		width: 40vh;
		height: 40vh;
		bottom: 0;
		left: 50%;
		margin-left: -20vh;
	}
	#keyboard > .box > svg
	{
		position: relative;
		width: 80%;
		height: 80%;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
	}
	#keyboard > .box > svg > path
	{
		fill: black;
		transition: fill 0.3s;
	}
	#keyboard > .box > svg > path.active
	{
		fill: #ffbb00;
	}
	#keys
	{
		position: absolute;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
		display: grid;
		grid-template-columns: 34% 32% 34%;
		grid-template-rows: 34% 32% 34%;
	}
	#history
	{
		position: relative;
		width: 48vh;
		left: 50%;
		margin-left: -24vh;
		min-height: 20vh;
		margin-bottom: 2vh;
		padding-top: 20vh;
		padding-bottom: 2vh;
		background: #111111;
	}
	#statement
	{
		position: relative;
		width: 48vh;
		left: 50%;
		margin-left: -24vh;
		margin-top: 2vh;
		padding-top: 2vh;
		padding-bottom: 50vh;
		background: #111111;
	}
	.statement
	{
		box-sizing: border-box;
		position: relative;
		background: #1b1b1b;
		border: solid 0.4vh #252525;
		width: 88%;
		margin-top: 1vh;
		margin-bottom: 1vh;
		padding-top: 0.4vh;
		min-height: 2vh;
	}
	.statement.A
	{
		left: 12%;
		padding-right: 0.5vh;
		text-align: right;
		border-top-left-radius: 1vh;
		border-bottom-left-radius: 1vh;
		border-right: none;
	}
	.statement.B
	{
		left: 0;
		padding-left: 0.5vh;
		text-align: left;
		border-top-right-radius: 1vh;
		border-bottom-right-radius: 1vh;
		border-left: none;
	}
	.statement:empty
	{
    	opacity: 0;
	}
	.statement > .char
	{
		display: inline-block;
		width: 2vh;
		height: 2vh;
		margin-left: 0.2vh;
		margin-right: 0.2vh;
		margin-top: 0.5vh;
		margin-bottom: 1vh;
	}
	.statement > .char > svg
	{
		width: 100%;
	}
	.statement > .char > svg > path
	{
		fill: black;
	}
	.statement > .char > svg > path.active
	{
		fill: #ffbb00;
	}
	#pair
	{
		display: flex;
		flex-direction: row;
		flex-wrap: wrap;
		justify-content: center;
		align-items: center;
		align-content: center;
		position: fixed;
		top: 2vh;
		left: 2vh;
		width: 7vh;
		height: 7vh;
		background: rgba(0,0,0,0.7);
		border: solid 0.3vh white;
		border-radius: 1vh;
	}
	#pair > svg
	{
		width: 5vh;
		fill: white;
	}
	#pairWindow
	{
		position: fixed;
		box-sizing: border-box;
		display: flex;
		flex-direction: column;
		flex-wrap: wrap;
		justify-content: flex-start;
		align-items: center;
		align-content: center;
		width: 49vh;
		left: 50%;
		margin-left: -24.5vh;
		height: 70vh;
		top: 10vh;
		background: black;
		border: solid 0.3vh white;
		color: white;
		padding: 1vh;
		font-size: 1.7vh;
	}
	#pairWindow > span.code
	{
		word-break: break-all;
	}
	#pairWindow > button
	{
		background: black;
		border: solid 0.3vh white;
		border-radius: 1vh;
		color: white;
		text-align: center;
		padding: 0.7vh;
		min-width: 30vh;
		letter-spacing: 0.1vh;
		margin-top: 0.5vh;
		margin-bottom: 1vh;
		font-size: 2vh;
	}
	#pairWindow > textarea
	{
		box-sizing: border-box;
		width: 95%;
		min-height: 7vh;
		background: black;
		border: solid 0.3vh white;
		color: white;
		text-align: center;
		padding: 0.7vh;
		min-width: 30vh;
		letter-spacing: 0.1vh;
		margin-top: 1vh;
		margin-bottom: 1vh;
	}
	#pairWindow.hidden
	{
		display: none;
	}
</style>
<script>
	const webRTC = {
	pc: null,
	channel: null,

	load: function() {
		if (this.pc) return; // unikamy ponownego tworzenia
		this.pc = new RTCPeerConnection();

		this.pc.ondatachannel = (e) => {
			this.channel = e.channel;
			this.channel.onopen = this.event.onopen;
			this.channel.onmessage = this.event.onmessage;
		};
	},

	event: {
		onopen: function() {
			console.log("KANAŁ OTWARTY");
			document.getElementById("pair")?.remove();
			document.getElementById("pairWindow")?.remove();
			document.getElementById("history").innerHTML = "";
		},
		onmessage: function(e) {
			const m = JSON.parse(e.data);
			if (m[0] === 1) system.user.write("B", m[1], m[2]);
			if (m[0] === 2) system.user.send("B", m[1]);
			if (m[0] === 3) system.user.delete("B");
		}
	},

	// --- Funkcja generowania oferty (A) ---
	getOffer: async function() {
		this.load();

		// Tworzymy kanał danych A -> B
		this.channel = this.pc.createDataChannel("tunnel");
		this.channel.onopen = this.event.onopen;
		this.channel.onmessage = this.event.onmessage;

		// Tworzymy ofertę
		const offer = await this.pc.createOffer();
		await this.pc.setLocalDescription(offer); // ustaw lokalnie ofertę
		await this._waitIceComplete();

		return this.pc.localDescription.sdp;
	},

	// --- Funkcja przyjmowania oferty (B) i generowania odpowiedzi ---
	acceptOffer: async function(offerSDP) {
		this.load();

		// Ustawiamy remote description z oferty A
		await this.pc.setRemoteDescription({ type: "offer", sdp: offerSDP });

		// Tworzymy kanał danych odpowiedzi (B -> A) automatycznie przez ondatachannel
		const answer = await this.pc.createAnswer();
		await this.pc.setLocalDescription(answer); // ustawiamy lokalnie odpowiedź
		await this._waitIceComplete();

		return this.pc.localDescription.sdp; // zwracamy SDP odpowiedzi
	},

	// --- Funkcja ustawiania odpowiedzi (A) ---
	acceptAnswer: async function(answerSDP) {
		this.load();

		// Sprawdzamy, czy lokalna oferta już istnieje
		if (this.pc.signalingState !== "have-local-offer") {
			console.error("Nie można ustawić remote answer – PC nie ma lokalnej oferty!");
			return;
		}

		await this.pc.setRemoteDescription({ type: "answer", sdp: answerSDP });
	},

	send: function(msg) {
		if (this.channel && this.channel.readyState === "open") {
			this.channel.send(msg);
		} else {
			console.warn("Kanał nie jest otwarty!");
		}
	},

	_waitIceComplete: function() {
		return new Promise(resolve => {
			if (!this.pc) return resolve();
			this.pc.onicecandidate = (e) => {
				if (!e.candidate) resolve();
			};
		});
	},
	code: function(sdp)
		{
			const data = 
			[
				{
					// v=0 -> przewidywalne, niepotrzebne
					reg: /^v=/i,
					func: s => ""  // zwracamy pusty string
				},
				{
					// o=- 0 0 IN IP4 127.0.0.1 -> większość przewidywalna, zostawiamy puste
					reg: /^o=/i,
					func: s => ""
				},
				{
					// s=- -> zawsze s=-, pomijamy
					reg: /^s=/i,
					func: s => ""
				},
				{
					// t=0 0 -> przewidywalne
					reg: /^t=/i,
					func: s => ""
				},
				{
					// a=ice-ufrag: -> zamiana nazwy na 1 znak + wartość bez zmian
					reg: /^a=ice-ufrag:/i,
					func: s => s.split(":")[1]
				},
				{
					// a=ice-pwd: -> 1 znak + wartość
					reg: /^a=ice-pwd:/i,
					func: s => s.split(":")[1]
				},
				{
					// a=fingerprint:sha-256: -> prefix "f" + wartość bez dwukropków, małe litery
					reg: /^a=fingerprint:/i,
					func: s => 
					{
						const d = (s.match(/fingerprint:sha-256 (?<d>.+)/).groups||{d:""}).d;
						return d.toLowerCase().replaceAll(":", "");
					}
				},
				{
					// m= -> zamiana nazwy na "m" + wartość
					reg: /^m=/i,
					func: s => s.substring(2)
				},
				{
					// c= -> zamiana nazwy na "c" + wartość
					reg: /^c=/i,
					func: s => s.substring(2)
				},
				{
					reg: /^a=candidate:/i,
					func: s =>
					{
						let parts = s.split(":");
						parts.shift(); // usuwamy "a=candidate"

						// połącz resztę w jeden string
						let val = parts.join("").toLowerCase();

						// sprasowanie powtarzalnych fragmentów
						val = val
							.replace(/\btyp\s+host\b/gi, "h")
							.replace(/\btyp\s+srflx\b/gi, "s")
							.replace(/\btyp\s+relay\b/gi, "r")
							.replace(/\bgeneration\s+0\b/gi, "g0")
							.replace(/\bnetwork-cost\s+999\b/gi, "n9");

						return val;
					}
				}
			];

			const lines = sdp.split(/\r?\n/).filter(l => l.trim().length > 0);
			let out = "";

			for (let line of lines)
			{
				// znajdź odpowiedni index w data
				let idx = data.findIndex(d => d.reg.test(line));
				if (idx === -1){continue}
				const func = data[idx].func;

				// zakodowanie wartości
				const value = func(line);

				// kodowanie długości wartości w 2 znaki base32
				let len32 = value.length.toString(32).padStart(2, "0");

				// kodowanie indeksu funkcji w 1 znak base32
				let idx32 = idx.toString(32);

				// dodanie do out: długość + indeks + wartość
				out += len32 + idx32 + value;
			}

			return escapeForLink(out);

			function escapeForLink(str)
			{
				return str.replace(/q| |\/|\.|-|\+|:|=|,|;|#|%|\?|@|!/g, match => {
					switch(match)
					{
						case "q": return "qq";
						case " ": return "qa";
						case "/": return "qb";
						case ".": return "qc";
						case "-": return "qd";
						case "+": return "qe";
						case ":": return "qf";
						case "=": return "qg";
						case ",": return "qh";
						case ";": return "qi";
						case "#": return "qj";
						case "%": return "qk";
						case "?": return "ql";
						case "@": return "qm";
						case "!": return "qn";
					}
				});
			}
		},
		decode: function(str)
		{
			const data = 
			[
				{ prefix: "v", func: () => "v=0" },
				{ prefix: "o", func: () => "o=- 0 0 IN IP4 127.0.0.1" },
				{ prefix: "s", func: () => "s=-" },
				{ prefix: "t", func: () => "t=0 0" },
				{ prefix: "u", func: val => "a=ice-ufrag:" + val },
				{ prefix: "p", func: val => "a=ice-pwd:" + val },
				{ prefix: "f", func: val => 
					{
						// fingerprint, przywracamy dwukropki co 2 znaki
						let hex = val.match(/.{1,2}/g).join(":");
						return "a=fingerprint:sha-256 " + hex;
					}
				},
				{ prefix: "m", func: val => "m=" + val },
				{ prefix: "c", func: val => "c=" + val },
				{ prefix: "i", func: val =>
					{
						val = val
							.replace(/h/g, "---h---")
							.replace(/s/g, "---s---")
							.replace(/r/g, "---r---")
							.replace(/g0/g, "---g0---")
							.replace(/n9/g, "---n0---");
						// ICE candidate: przywracamy spacje i powtarzalne fragmenty
						val = val
							.replace(/---h---/g, "typ host ")
							.replace(/---s---/g, "typ srflx ")
							.replace(/---r---/g, "typ relay ")
							.replace(/---g0---/g, "generation 0 ")
							.replace(/---n0---/g, "network-cost 999 ");

						// dodaj prefiks a=candidate:
						return "a=candidate:" + val;
					}
				}
			];

			// najpierw odwracamy escape znaków
			str = unescapeFromLink(str);

			let pos = 0;
			let out = "";

			while (pos < str.length)
			{
				// odczyt długości wartości (2 znaki base32)
				let len32 = str.substr(pos, 2);
				let len = parseInt(len32, 32);
				pos += 2;

				// odczyt indeksu funkcji (1 znak base32)
				let idx32 = str[pos];
				let idx = parseInt(idx32, 32);
				pos += 1;

				// odczyt wartości
				let val = str.substr(pos, len);
				pos += len;

				// przywracanie linii SDP
				const func = data[idx]?.func || (v => v);
				out += func(val) + "\r\n";
			}

			return out;

			// ----------------------
			// funkcje escape odwrotne
			// ----------------------
			function unescapeFromLink(str)
			{
				let out = "";
				for (let i = 0; i < str.length; i++)
				{
					if (str[i] === "q")
					{
						const next = str[i+1];
						switch(next)
						{
							case "q": out += "q"; i++; break;
							case "a": out += " "; i++; break;
							case "b": out += "/"; i++; break;
							case "c": out += "."; i++; break;
							case "d": out += "-"; i++; break;
							case "e": out += "+"; i++; break;
							case "f": out += ":"; i++; break;
							case "g": out += "="; i++; break;
							case "h": out += ","; i++; break;
							case "i": out += ";"; i++; break;
							case "j": out += "#"; i++; break;
							case "k": out += "%"; i++; break;
							case "l": out += "?"; i++; break;
							case "m": out += "@"; i++; break;
							case "n": out += "!"; i++; break;
							default: out += "q"; break;
						}
					}
					else
					{
						out += str[i];
					}
				}
				return out;
			}
		},
};

</script>
<script>
	const system =
	{
		load: function()
		{
			webRTC.load() // musi być zawsze
			const keyboard = document.getElementById("keyboard");
			keyboard.addEventListener("dragstart", e => e.preventDefault());
			keyboard.addEventListener("drop", e => e.preventDefault());
			const keys = document.getElementById("keys")
			for (let i=0 ; i<9 ; i++)
			{
				const div = document.createElement("div")
				div.dataset.id = "187206345"[i]
				keys.appendChild(div)
				div.addEventListener("pointerdown",system.keys.pointerdown)
				div.addEventListener("pointermove",system.keys.pointermove)
				div.addEventListener("pointerup",system.keys.pointerup)
			}
			document.getElementById("pair").onclick = function()
			{
				const w = document.getElementById("pairWindow")
				if (w.className)
				{
					w.className = ""
				}
				else
				{
					w.className = "hidden"
				}
			}
			const buttons = document.getElementById("pairWindow").getElementsByTagName("button")
			buttons[0].onclick = async function()
			{
				const w = document.getElementById("pairWindow")
				w.innerHTML = ""
				let span = document.createElement("span")
				span.className = "code"
				offer = await webRTC.getOffer();
				const code = webRTC.code(offer)
				span.innerHTML = code
				w.appendChild(span)
				const copy = document.createElement("button")
				copy.innerHTML = "Kopiuj"
				w.appendChild(copy)
				copy.dataset.copy = code
				copy.onclick = system.copy
				span = document.createElement("span")
				span.innerHTML = "Jesteś urządzeniem A. Wyślij powyższy kod na urządzenie B i poproś o kod zwrotny. Kod zdwotny wklej w okno niżej i kliknij paruj."
				w.appendChild(span)
				const textarea = document.createElement("textarea")
				textarea.innerHTML = "miejsce_na_kod_z_urzadzenia_B"
				w.appendChild(textarea)
				const button = document.createElement("button")
				button.innerHTML = "Paruj"
				button.onclick = async function()
				{
					const code = document.getElementById("pairWindow").getElementsByTagName("textarea")[0].value
					await webRTC.acceptAnswer(webRTC.decode(code));
				}
				w.appendChild(button)
			}
			buttons[1].onclick = async function()
			{
				const w = document.getElementById("pairWindow")
				w.innerHTML = ""
				let span = document.createElement("span")
				span.innerHTML = "Jesteś urządzeniem B. W okno niżej wklej kod z urządzenia A i kliknij paruj. Aplikacja wygeneruje kod zwrotny. Wyślij go na urządzenie A i poczekaj na sparowanie."
				w.appendChild(span)
				const textarea = document.createElement("textarea")
				textarea.innerHTML = "miejsce_na_kod_z_urzadzenia_A"
				w.appendChild(textarea)
				const button = document.createElement("button")
				button.innerHTML = "Paruj"
				button.onclick = async function()
				{
					let code = document.getElementById("pairWindow").getElementsByTagName("textarea")[0].value
					answer = await webRTC.acceptOffer(webRTC.decode(code));
					const w = document.getElementById("pairWindow")
					w.innerHTML = ""
					let span = document.createElement("span")
					span.className = "code"
					code = webRTC.code(answer)
					span.innerHTML = code
					w.appendChild(span)
					const copy = document.createElement("button")
					copy.innerHTML = "Kopiuj"
					w.appendChild(copy)
					copy.dataset.copy = code
					copy.onclick = system.copy
					span = document.createElement("span")
					span.innerHTML = "Wyślij kod na urządzenie A i poczekaj na sparowanie"
					w.appendChild(span)
				}
				w.appendChild(button)
			}
		},
		keys:
		{
			path: [],
			pointerdown: function(event)
			{
				const elemUnderFinger = document.elementFromPoint(event.clientX, event.clientY);
				const id = Number(elemUnderFinger.dataset.id);
				if (id)
				{
					system.keys.path = [id];
				}
			},
			pointermove: function(event)
			{
				if (system.keys.path.length < 1){return}
				const elemUnderFinger = document.elementFromPoint(event.clientX, event.clientY);
				const id = Number(elemUnderFinger.dataset.id);
				const lastPaht = system.keys.path[system.keys.path.length-1];
				if (lastPaht!=id)
				{
					system.keys.path.push(id);
					system.action(system.keys.path);
				}
			},
			pointerup: function(event)
			{
				if (system.keys.path.length < 1){return}
				const elemUnderFinger = document.elementFromPoint(event.clientX, event.clientY);
				const id = Number(elemUnderFinger.dataset.id);
				const lastPaht = system.keys.path[system.keys.path.length-1];
				if (id != lastPaht)
				{
					system.keys.path.push(id);
				}
				system.action(system.keys.path,"complete");
				system.keys.path = [];
			},
		},
		action(path,complete)
		{
			let drawPath = [];
			for (let i=1 ; i<path.length ; i++)
			{
				const a = path[i]
				const b = path[i-1]
				if (a==0 || b==0){continue}
				if (Math.abs(a-b) === 1)
				{
					const line = Math.min(a,b)-1
					if (line >= 0)
					{
						drawPath.push(line)
					}
				}
				else if ((a===1 && b===8) || (a===8 && b===1))
				{
					drawPath.push(7)
				}
			}
			drawPath = drawPath.filter((value, index, self) => self.indexOf(value) === index)
			drawPath = drawPath.sort((a, b) => a - b)
			system.draw(0,drawPath)
			if (complete)
			{
				system.draw()
				if (path.includes(0))
				{
					if (path.length != 3 || !path[0] || !path[2])
					{
						system.user.write("A",0)
					}
					else if (path[0] === 2 && path[2]=== 6)
					{
						system.user.write("A",25,complete)
					}
					else if (path[0] === 8 && path[2]=== 4)
					{
						system.user.write("A",26,complete)
					}
					else if (path[0] === 6 && path[2]=== 2)
					{
						system.user.delete("A")
					}
					else if (path[0] === 4 && path[2]=== 8)
					{
						system.user.send("A",system.user.statement.A)
					}
					else
					{
						system.user.write("A",0)
					}
				}
				else
				{
					const char = system.get.char(drawPath)
					if (char)
					{
						system.user.write("A",char,complete)
					}
					else
					{
						system.user.write("A",0)
					}
				}
			}
			else
			{
				const char = system.get.char(drawPath)
				if (char)
				{
					system.user.write("A",char,complete)
				}
				else
				{
					system.user.write("A",0)
				}
			}
		},
		get:
		{
			char: function(path)
			{
				if (path.length > 3)
				{
					return 0
				}
				if (path[0] === 0 && path[path.length-1] > 3)
				{
					for (let i=0 ; i<path.length ; i++)
					{
						if (path[i] < 3)
						{
							path[i] += 8
						}
					}
					path = path.sort((a, b) => a - b)
				}
				for (let i=1 ; i<path.length ; i++)
				{
					if (path[i] - path[i-1] != 1)
					{
						return 0
					}
				}
				return (path[0]*3)+path.length
			},
			path: function(char)
			{
				const data =
				[
					[],
					[0],
					[0,1],
					[0,1,2],
					[1],
					[1,2],
					[1,2,3],
					[2],
					[2,3],
					[2,3,4],
					[3],
					[3,4],
					[3,4,5],
					[4],
					[4,5],
					[4,5,6],
					[5],
					[5,6],
					[5,6,7],
					[6],
					[6,7],
					[0,6,7],
					[7],
					[0,7],
					[0,1,7],
					[],
					[6,7,2,3],
					[0,1,2,3,4,5,6,7],
				]
				return data[char]
			},
		},
		draw(svg,path)
		{
			if (!svg)
			{
				svg = document.getElementById("keyboard").getElementsByTagName("svg")[0]
			}
			const pieces = Array.from(svg.children);
			for (let i=0 ; i<pieces.length ; i++)
			{
				pieces[i].classList.remove("active");
			}
			for (let i=0 ; i<(path||[]).length ; i++)
			{
				pieces[path[i]].classList.add("active");
			}
		},
		user:
		{
			statement:
			{
				A: [],
				B: [],
			},
			write: function(user,h,complete)
			{
				if (complete)
				{
					system.user.statement[user].push(h);
				}
				const statement = document.getElementById("statement").getElementsByClassName(user)[0];
				if (h > 0 && h < 26)
				{
					const muted = statement.getElementsByClassName("muted")[0]
					if (muted)
					{
						muted.remove()
					}
					const path = system.get.path(h)
					const char = document.createElement("span")
					char.classList.add("char")
					if (!complete)
					{
						char.classList.add("muted")
					}
					char.innerHTML = `<svg viewBox="0 0 700 700"><path d="M0 17 L0 338 L70 338 L70 87 L0 17 Z"></path><path d="M0 362 L0 683 L70 613 L70 362 L0 362 Z"></path><path d="M17 700 L338 700 L338 630 L87 630 L17 700 Z"></path><path d="M362 700 L683 700 L613 630 L362 630 L362 700 Z"></path><path d="M700 362 L700 683 L630 613 L630 362 L700 362 Z"></path><path d="M700 17 L700 338 L630 338 L630 87 L700 17 Z"></path><path d="M362 0 L683 0 L613 70 L362 70 L362 0 Z"></path><path d="M17 0 L338 0 L338 70 L87 70 L17 0 Z"></path></svg>`
					statement.appendChild(char)
					system.draw(char.children[0],path)
				}
				else if (h === 26 && complete)
				{
					const muted = statement.getElementsByClassName("muted")[0]
					if (muted)
					{
						muted.remove()
					}
					const char = document.createElement("br")
					statement.appendChild(char)
				}
				if (webRTC.channel && user === "A")
				{
					if (complete)
					{
						webRTC.send(`[1,${h},1]`)
					}
					else
					{
						webRTC.send(`[1,${h},0]`)
					}
				}
			},
			send: function(user,message)
			{
				const history = document.getElementById("history")
				const statement = document.createElement("div")
				statement.classList.add("statement")
				statement.classList.add(user)
				history.appendChild(statement)
				system.refresh(statement,system.user.statement[user])
				system.user.statement[user] = [];
				system.refresh(document.getElementById("statement").getElementsByClassName(user)[0],[])
				if (webRTC.channel && user === "A")
				{
					webRTC.send(`[2,${JSON.stringify(message)}]`)
				}
			},
			delete: function(user)
			{
				system.user.statement[user].pop();
				system.refresh(document.getElementById("statement").getElementsByClassName(user)[0],system.user.statement[user])
				if (webRTC.channel && user === "A")
				{
					webRTC.send("[3]")
				}
			}
		},
		refresh: function(div,statement)
		{
			div.innerHTML  = "";
			for (const h of statement)
			{
				if (h > 0 && h < 26)
				{
					const path = system.get.path(h)
					const char = document.createElement("span")
					char.classList.add("char")
					char.innerHTML = `<svg viewBox="0 0 700 700"><path d="M0 17 L0 338 L70 338 L70 87 L0 17 Z"></path><path d="M0 362 L0 683 L70 613 L70 362 L0 362 Z"></path><path d="M17 700 L338 700 L338 630 L87 630 L17 700 Z"></path><path d="M362 700 L683 700 L613 630 L362 630 L362 700 Z"></path><path d="M700 362 L700 683 L630 613 L630 362 L700 362 Z"></path><path d="M700 17 L700 338 L630 338 L630 87 L700 17 Z"></path><path d="M362 0 L683 0 L613 70 L362 70 L362 0 Z"></path><path d="M17 0 L338 0 L338 70 L87 70 L17 0 Z"></path></svg>`
					div.appendChild(char)
					if (h < 25)
					{
						system.draw(char.children[0],path)
					}
				}
				else if (h === 26)
				{
					const char = document.createElement("br")
					div.appendChild(char)
				}
			}
		},
		copy: async function(event)
		{
			const text = event.target.dataset.copy
			try
			{
				await navigator.clipboard.writeText(text);
				console.log("Skopiowano!");
			}
			catch(err)
			{
				console.error("Błąd kopiowania:", err);
			}
		}
	}
</script>
</head>
<body onload="system.load()">
	<div id="history"></div>
	<div id="statement">
		<div class="statement B"></div>
		<div class="statement A"></div>
	</div>
	<div id="keyboard">
		<div class="box">
			<svg viewBox="0 0 700 700">
				<path d="M0 17 L0 338 L70 338 L70 87 L0 17 Z"></path>
				<path d="M0 362 L0 683 L70 613 L70 362 L0 362 Z"></path>
				<path d="M17 700 L338 700 L338 630 L87 630 L17 700 Z"></path>
				<path d="M362 700 L683 700 L613 630 L362 630 L362 700 Z"></path>
				<path d="M700 362 L700 683 L630 613 L630 362 L700 362 Z"></path>
				<path d="M700 17 L700 338 L630 338 L630 87 L700 17 Z"></path>
				<path d="M362 0 L683 0 L613 70 L362 70 L362 0 Z"></path>
				<path d="M17 0 L338 0 L338 70 L87 70 L17 0 Z"></path>
			</svg>
			<div id="keys"></div>
		</div>
	</div>
	<div id="pair">
		<svg viewBox="0 0 254.809 254.809">
			<path d="M231.767,156.697l-14.616-3.567c-13.105-3.198-24.741-18.747-29.353-31.425c-12.706-34.93,5.111-71.203,11.865-83.022 c0.605-1.059,0.757-2.318,0.421-3.491c-0.336-1.173-1.131-2.162-2.206-2.74l-59.37-31.913c-1.286-0.691-2.827-0.719-4.138-0.075 c-1.311,0.645-2.23,1.882-2.468,3.323c-3.147,19.041-16.47,41.674-25.54,54.025l29.458,15.697 c4.61,2.478,8.082,6.784,9.525,11.813c1.444,5.032,0.783,10.526-1.815,15.073c-3.869,6.77-13.761,26.143-14.302,47.619 l0.949,0.598c10.447,6.584,18.385,16.481,22.543,28.108c3.32,9.283,10.309,16.793,19.33,20.77 c9.021,3.977,18.844,2.792,28.372,0.259c9.093-2.417,33.969-7.821,33.969-7.821c5.57-1.225,8.9-6.436,10.263-12.023 C246.952,168.489,241.182,158.994,231.767,156.697z"></path>
			<path d="M162.61,210.966l-14.616-3.567c-13.106-3.198-24.741-18.747-29.353-31.424c-12.707-34.932,5.113-71.207,11.866-83.024 c0.606-1.06,0.757-2.319,0.421-3.492c-0.337-1.173-1.133-2.16-2.208-2.738L69.351,54.809c-0.668-0.359-1.404-0.539-2.142-0.539 c-0.683,0-1.366,0.154-1.996,0.464c-1.311,0.645-2.23,1.882-2.468,3.323c-3.382,20.467-12.767,36.782-21.743,48.317 C55.2,117.649,64.33,135.043,64.33,154.54c0,15.594-5.844,29.841-15.444,40.693l12.134,7.646 c10.447,6.584,18.385,16.481,22.543,28.108c3.32,9.283,10.309,16.793,19.33,20.77c4.612,2.033,9.549,3.051,14.487,3.051 c8.988,0,18.914-2.108,47.854-10.613c6.498-1.995,8.9-6.436,10.263-12.023C177.795,222.758,172.025,213.264,162.61,210.966z"></path> <path d="M31.079,117.639c-3.103,3.113-5.737,5.413-7.469,6.841c-0.76,0.556-1.509,1.137-2.235,1.764 c-8.116,7.004-12.431,17.441-11.629,28.131c0.801,10.69,6.624,20.367,15.694,26.083l10.545,6.645 c8.247-8.395,13.346-19.892,13.346-32.563C49.33,139.518,42.165,126.146,31.079,117.639z"></path>
		</svg>
	</div>
	<div id="pairWindow" class="hidden">
		<button>Inicjowanie Parowania</button>
		<button>Dołączanie do parowania</button>
		<span>Parowanie wykorzystuje technologię WebRTC<br>
			Umożliwia ona połączenie dwóch urządzeń z pominięciem serwera. Tradycyjne komunikatory do działania potrzebują serwera w firmie. Użytkownicy wysyłają wiadomości na serwer, a on przesyła je dalej. Tu jest inaczej, wiadomość jest wysyłana od razu na drugie urządzenie.<br><br>
			Instrukcja parowania<br>
			Na jednym urządzeniu (A) kliknij inicjowanie parowania. Aplikacja pokaże specjalny kod. Kod zawiera instrukcję dla drugiego urządzenia jak może się z nim skontaktować. Wyślij kod do osoby mającej drugie urządzenie (B). Na urządzeniu B wybierz dołączenie do parowania, wklej kod i kliknij guzik. Aplikacja wygeneruje kod zwrotny, prześlij je na urządzenie A i wprowadź w pole tekstowe i zatwierdź. Po sparowaniu zniknie okno parowania i będzie możliwa komunikacja. Czasami parowanie może się nie udać, technologia ma swoje ograinczenia. Po udanym parowaniu nie odświeżaj karty dopóki chcesz utrzymać połączenie.
		</span>
	</div>
</body>
</html>
